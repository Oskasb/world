[
  {
    "SHADER_PROGRAMS": {

      "TERRAIN_SHADER":{

        "vertexOceanInstancing": [

          "precision highp float;",
          "uniform sampler2D heightmap;",
          "uniform sampler2D terrainmap;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform float systemTime;",

          "attribute vec4 texelRowSelect;",
          "attribute vec4 lifecycle;",
          "attribute vec4 orientation;",
          "attribute vec4 vertexColor;",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec3 offset;",
          "attribute vec3 scale3d;",
          "attribute vec2 uv;",
          "attribute vec4 sprite;",

          "uniform vec3 heightmaptiles;",

          "varying vec4 vColor;",
          "varying vec2 vUv;",
          "varying vec2 heightSampler;",

          "uniform vec3 ambientLightColor;",
          "uniform vec3 sunLightColor;",

          "uniform vec3 sunLightDirection;",
          "varying vec3 sunDir;",

          "uniform vec3 cameraPosition;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec3 faceNormal;",
          "varying vec2 tileOffset;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "varying float heightSample;",
          "varying float minHeight;",
          "varying float maxHeight;",
          "varying float vReflectionFactor;",
          "varying vec3 vReflect;",
          "varying vec3 fragPos;",
          "void main(){",

          "vPosition = position;",
          "terrainPosition = position;",
          "float txw = heightmaptiles.z;",
          "float txPointOffset = 1.0/txw;",
          "float shift = txPointOffset * 1.0;",
          "vec4 quat = orientation.xyzw;",

          "minHeight = offset.y;",
          "maxHeight = scale3d.y - minHeight;",
          "vUv = uv;",

          "tileScale = 1.0/heightmaptiles.xy;",

          "tileOffset = vec2(sprite.x * tileScale.x + txPointOffset*0.5, sprite.y * tileScale.y + txPointOffset*0.5);",

          "vec2 scaledVPos = vec2(position.x*0.5 + 0.5, position.z *0.5 + 0.5)*tileScale;",

          "heightSampler = (scaledVPos + tileOffset);",

          "vec4 sample = texture2D( heightmap, heightSampler);",
          "heightSample = sample.r;",


          "vPosition.x = vPosition.x *  scale3d.x;",
          "vPosition.y = vPosition.y *  scale3d.y * 100.0 -offset.y;",
          "vPosition.z = vPosition.z *  scale3d.z;"  ,

          "vNormal.x = 0.0;",
          "vNormal.y = 1.0;",
          "vNormal.z = 0.0;",

          "float intensity = max( 0.4 + dot(vNormal, sunLightDirection ) * 0.5, 0.0);",
          "sunDir = sunLightColor * intensity * (0.3+intensity*intensity*0.3);",

          "float ambIntensity = 0.75 * (sin(systemTime*0.3 + (offset.x+(vPosition.x*0.2)+systemTime)*1.0)*0.2+0.2);",

          "vColor.r = sunDir.r + ambientLightColor.r * ambIntensity ;",
          "vColor.g = sunDir.g + ambientLightColor.g * ambIntensity;",
          "vColor.b = sunDir.b + ambientLightColor.b * ambIntensity;",
          "vColor.a = 1.0;",

          "fragPos = offset + vPosition;",

          "gl_Position = projectionMatrix * modelViewMatrix * vec4( fragPos, 1.0 );",
          "fogDepth = gl_Position.z*1.0;",
          "}",
          ""
        ],


        "fragmentOceanInstancing":[
          "precision highp float;",
          "uniform float systemTime;",
          "uniform vec3 cameraPosition;",
          "uniform vec3 sunLightDirection;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "uniform sampler2D terrainmap;",
          "uniform sampler2D tx0;",
          "uniform sampler2D tx0nm;",
          "uniform sampler2D tx1;",
          "uniform sampler2D envMap;",
          "uniform vec2 tx0tiles;",
          "varying vec2 vUv;",
          "varying vec3 sunDir;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec4 vColor;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec3 faceNormal;",
          "varying vec2 tileOffset;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "varying float heightSample;",
          "varying float minHeight;",
          "varying float maxHeight;",
          "varying vec3 fragPos;",
          "void main(){",

          "float tileCount = 8.0;",
          "float tileXuv = max(0.001, min(vUv.x*1.0, 0.9999)) * tileCount;",
          "float tileYuv = max(0.001, min(vUv.y*1.0, 0.9999)) * tileCount;",
          "float uvX = tileXuv * 1.0 - floor(tileXuv * 1.0)*0.9999;",
          "float uvY = tileYuv * 1.0 - floor(tileYuv * 1.0)*0.9999;",
          "vec2 tileUv = vec2(0.005 + uvX*0.990, 0.005 + uvY*0.990);",

          "vec2 scaledVPos = vec2(terrainPosition.x*0.5 + 0.5, terrainPosition.z *0.5 + 0.5)*tileScale;",

          "vec2 terrainSampler = (scaledVPos + tileOffset);",

          "vec4 terrainMapSample = texture2D( terrainmap, terrainSampler);",

          "float twoPi = 6.2831;",
          "float depth = min(max(heightSample*1.2*(maxHeight-minHeight)-0.1, 0.0), 1.0);",

          "float mod = sin(systemTime*0.42)*0.15 + cos(systemTime*0.3)*0.15 +0.3;",
          "float mod2 = sin(systemTime*0.32+terrainSampler.x*1.1)*0.15 +cos(systemTime*0.25+terrainSampler.y*1.1)*0.15 + 0.2 +mod;",



          "vec4 sprite = vec4(0.0, 8.0, 1.0, 1.0);",
          "vec2 tileScale = 0.5/tx0tiles;",
          "tileScale.y /= sprite.z;",
          "vec2 scaledUv = tileUv*tileScale;",
          "scaledUv.y /= sprite.z;",

          "float smoothFactor  = 0.0;",
          "float sampleBlue = terrainMapSample.b;",
          "float sampleGreen = terrainMapSample.g;",

          "float waterRow = 16.0;",
          "float depthScale = 0.98;",
          "float modFactor = 0.05;",


          "float scatter = (cos(vPosition.z*113.0) + sin(vPosition.x*113.0))*0.012 + (cos(vPosition.z*25.0) + sin(vPosition.x*25.0))*0.012;",

          "depth = depth * 0.99 + modFactor*depth*sin((vPosition.x+mod2) * twoPi*0.125)  + modFactor*depth*cos((vPosition.z+mod2) * twoPi*0.25+ mod) ;",
          "depth = depth * 0.99 + modFactor*depth*sin(vPosition.x * twoPi*0.25)  + modFactor*depth*cos((vPosition.z+mod2) * twoPi*0.125+ mod) ;",
          "depth = depth * 0.99 + modFactor*depth*sin((vPosition.x+mod2) * twoPi*0.25)   + modFactor*depth*cos(vPosition.z * twoPi*0.25+ mod) ;",

          "depth = min(max(depth*1.9-0.05, 0.0), 1.0);",

          "vec2 tileDepthMod = vec2(min(floor(max((depth -0.001) +scatter*0.75*(sin((vPosition.x+systemTime)*(1.2))+0.5) +scatter*mod, 0.01) * 10.0), 7.0), waterRow);",
          "vec2 tileDepthModOffset = vec2(tileDepthMod.x * tileScale.x, (tileDepthMod.y-sprite.w) * tileScale.y / sprite.z);",
          "vec2 tileDepthModUv = vec2(scaledUv + tileDepthModOffset);",
          "vec4 txColorDepthMod01 = texture2D( tx0, tileDepthModUv);",
          "vec4 txNmDepthMod01 = texture2D( tx0nm, tileDepthModUv);",
          "vec4 txColorBase = txColorDepthMod01;",
          "vec4 txNmBase =  txNmDepthMod01;",

          "vec4 txColor = txColorBase;",

          "txColor.r += vNormal.x * 0.0 + tileUv.x *0.0;",
          "txColor.g += vNormal.y * 0.0 + tileUv.y *0.0;",
          "txColor.b += vNormal.z * 0.1;",
          "vec4 lightColor = vec4(sunDir, 1.0);",
          "float intensity = max( 0.01 + dot(txNmBase.rgb, sunLightDirection ) * 0.99, 0.0);",

          "vec3 transposedFragPos = fragPos + txNmBase.xyz+ txNmBase.xyz+ txNmBase.xyz;",
          "transposedFragPos.y += sin(systemTime*1.0 + txNmDepthMod01.x*20.0)*1.51 ;",
          "transposedFragPos.x += cos(systemTime*1.0 + txNmDepthMod01.y*20.0)*1.51 ;",

          "vec3 cameraToFrag = normalize(transposedFragPos-cameraPosition);",
          "vec4 reflectionColor = texture2D( envMap, cameraToFrag.xy);",

          "vec4 baseColor = vColor * txColor * (intensity*0.25 + 0.75) + txColor * lightColor*intensity*2.0;",

          "float normalFactor = dot(cameraToFrag, vNormal);",

          "float reflectionFactor =  0.0 + max(0.0, 1.0 - txColor.r*3.5) * cos(normalFactor*6.10*normalFactor) * 0.55;",

          "reflectionColor *=  reflectionFactor;",

          "gl_FragColor = baseColor + reflectionColor;",

          "float fogFactor = min(fogDensity * fogDepth*0.56, 0.8);",
          "fogFactor += min(fogDensity * fogDepth*1.56, 0.2);",
          "gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor,  fogFactor );",

          "}",
          ""

        ],


        "vertexBigOcean": [

          "precision highp float;",
          "uniform sampler2D heightmap;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform float systemTime;",

          "attribute vec4 texelRowSelect;",
          "attribute vec4 lifecycle;",
          "attribute vec4 orientation;",
          "attribute vec4 vertexColor;",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec3 offset;",
          "attribute vec3 scale3d;",
          "attribute vec2 uv;",
          "attribute vec4 sprite;",

          "uniform vec3 heightmaptiles;",

          "varying vec4 vColor;",
          "varying vec2 vUv;",
          "varying vec2 heightSampler;",

          "uniform vec3 ambientLightColor;",
          "uniform vec3 sunLightColor;",

          "uniform vec3 sunLightDirection;",
          "varying vec3 sunDir;",

          "uniform vec3 cameraPosition;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "varying float heightSample;",
          "varying float minHeight;",
          "varying float maxHeight;",
          "varying float vReflectionFactor;",
          "varying vec3 vReflect;",
          "varying vec3 fragPos;",
          "varying vec2 scaledVPos;",
          "varying vec2 center;",
          "varying vec3 waveSmall;",
          "varying vec3 waveBig;",
          "varying float elevationFactor;",
          "void main(){",

          "elevationFactor = 1.0 + floor(cameraPosition.y * 0.05);",

          "float distX = abs(position.x-0.5);",
          "float distZ = abs(position.z-0.5);",

          "float distScaleX = floor(distX*0.011)*128.0;",
          "float distScaleZ = floor(distZ*0.011)*128.0;",

          "elevationFactor += distScaleX + distScaleZ;",

          "vPosition.x = (position.x + sign(position.x) * distScaleX)*elevationFactor;",
          "vPosition.z = (position.z + sign(position.z) * distScaleZ)*elevationFactor;",

          "float txw = heightmaptiles.z;",
          "float txPointOffset = 1.0/(txw+1.0);",
          "float tileFactor = elevationFactor*2.0/(txw);",

          "float shift = txPointOffset * 1.0;",
          "float shiftSubOne = 1.0/(txw-1.0);",
          "center.x = floor(offset.x / elevationFactor) * elevationFactor;",
          "center.y = floor(offset.z / elevationFactor) * elevationFactor;",

          "minHeight = -3.0;",
          "maxHeight = 0.0;",

          "vec4 quat = orientation.xyzw;",

          "terrainPosition.x = position.x*tileFactor;",
          "terrainPosition.y = 0.0;",
          "terrainPosition.z = position.z*tileFactor;",



          "scaledVPos.x =  ((center.x*(1.0-shift)) * shiftSubOne+shift*0.0  + (terrainPosition.x ) * 0.5 + 0.5);",
          "scaledVPos.y =  ((center.y*(1.0-shift)) * shiftSubOne+shift*0.0  + (terrainPosition.z ) * 0.5 + 0.5);",

          "scaledVPos.x = floor(scaledVPos.x*2.0*(txw))*0.5*shift;",
          "scaledVPos.y = floor(scaledVPos.y*2.0*(txw))*0.5*shift;",

          "heightSampler.x = scaledVPos.x;",
          "heightSampler.y = scaledVPos.y;",

          "vec4 sample = texture2D( heightmap, heightSampler);",

          "float distManhattan = max((distX+distZ-70.0)*elevationFactor, 0.0);",

          "float nearness = 1.0 / (max(distManhattan*0.1, 1.0));",

          "heightSample = sample.r*nearness;",

          "vUv.x = mod((position.x/256.0)+0.5, 1.0);",
          "vUv.y = mod((position.z/256.0)+0.5, 1.0);",





          "vPosition.x += center.x -0.5;",
          "vPosition.z += center.y -0.5;",

          "float waveX = sin(vPosition.x*2.0 + systemTime*0.80);",
          "float waveY = cos(vPosition.z*2.0 + systemTime*0.80);",
          "float waveZ1 = sin(systemTime*0.25+vPosition.x*0.5+vPosition.z*0.002);",
          "float waveZ2 = cos(systemTime*0.50+(vPosition.z*2.0-waveZ1*1.0+vPosition.x*0.025)*0.5-waveZ1*1.3);",
          "waveSmall.x = waveX;",
          "waveSmall.z = waveY;",
          "waveSmall.y = waveX*waveY+waveY*waveX;",
          "waveBig.x = waveZ1;",
          "waveBig.z = waveZ2;",
          "waveBig.y = waveZ1 + waveZ2;",
          "vPosition.y = waveSmall.y*0.04 + waveBig.y*0.03;",

          "vNormal.y = 12.0-vPosition.y;",
          "vNormal.x = waveX*0.25 +waveZ1*0.2;",
          "vNormal.z = waveY*0.25 +waveZ2*0.2;",
          "vPosition.x += vNormal.x*0.25;",
          "vPosition.z += vNormal.z*0.25;",

          "vNormal = normalize(vNormal);",

          "float intensity = abs(sunLightDirection.y);",
          "sunDir = sunLightColor * intensity * (0.3+intensity*intensity*0.3);",

          "float ambIntensity = 0.75 * (sin(systemTime*0.3 + (offset.x+(vPosition.x*0.2)+systemTime)*1.0)*0.2+0.2);",

          "vColor.r = sunDir.r + ambientLightColor.r * ambIntensity ;",
          "vColor.g = sunDir.g + ambientLightColor.g * ambIntensity;",
          "vColor.b = sunDir.b + ambientLightColor.b * ambIntensity;",
          "vColor.a = 1.0;",

          "fragPos = vPosition;",

          "gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );",
          "fogDepth = gl_Position.z*1.0;",
          "}",
          ""
        ],


        "fragmentBigOcean":[
          "precision highp float;",
          "uniform float systemTime;",
          "uniform vec3 cameraPosition;",
          "uniform vec3 sunLightDirection;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "uniform sampler2D tx0;",
          "uniform sampler2D tx0nm;",
          "uniform sampler2D tx1;",
          "uniform sampler2D envMap;",
          "uniform vec2 tx0tiles;",
          "varying vec2 vUv;",
          "varying vec3 sunDir;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec4 vColor;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "varying vec2 scaledVPos;",
          "varying float heightSample;",
          "varying float minHeight;",
          "varying float maxHeight;",
          "varying vec3 fragPos;",
          "varying vec3 waveSmall;",
          "varying vec3 waveBig;",
          "varying float elevationFactor;",
          "void main(){",

          "vec2 tileScale = 1.0/tx0tiles;",
          "float tileCount = tx0tiles.x*16.0;",


          "float tileXuv = (max(0.001, min(mod(vUv.x*elevationFactor, 1.0), 0.999)) * tileCount);",
          "float tileYuv = (max(0.001, min(mod(vUv.y*elevationFactor, 1.0), 0.999)) * tileCount);",
          "float uvX = ((tileXuv * 1.0 - floor(tileXuv * 1.0005)*0.99995)) * 1.0;",
          "float uvY = ((tileYuv * 1.0 - floor(tileYuv * 1.0005)*0.99995)) * 1.0;",
          "float pixelShrink = 0.07;",
          "vec2 tileUv = vec2(pixelShrink + uvX*(1.0-pixelShrink*2.0), pixelShrink + uvY*(1.0-pixelShrink*2.0));",
          "vec2 scaledUv = tileUv*tileScale;",


          "float twoPi = 6.2831;",
          "float depth = min(max(heightSample*(80.0/(maxHeight-minHeight)+vPosition.y*25.0), 0.0), 1.0);",

          "float waveX = sin(systemTime*0.25);",
          "float waveY = cos(systemTime*0.25);",

          "float mod = sin((fragPos.x+systemTime*1.2+waveX)*0.25 + waveX*0.2 )*0.1 + cos((fragPos.z+ systemTime*1.2+waveY)*0.25+ waveY*0.2 )*0.1 +0.3;",
          "float mod2 = waveX*sin(systemTime*0.2+fragPos.x*0.25)*0.15 + waveY*cos(systemTime*0.2+fragPos.z*0.25)*0.15 + 0.3;",
          "depth = min(max(depth*((mod + mod2)*2.0+vPosition.y*vPosition.y*10.0), 0.0), 1.0);",


          "float waterRow = 16.0;",
          "float depthScale = 0.9998;",
          "float modFactor = 0.05;",

          "vec2 tileDepthMod = vec2(min(floor(max((depth), 0.0) * 7.0), 7.0), waterRow);",

          "vec2 tileDepthModOffset = vec2(tileDepthMod.x *tileScale.x, (tileDepthMod.y-1.0) * tileScale.y);",
          "vec2 tileDepthModUv = vec2(scaledUv + tileDepthModOffset);",
          "vec4 txColorDepthMod01 = texture2D( tx0, tileDepthModUv);",
          "vec4 txNmDepthMod01 = texture2D( tx0nm, tileDepthModUv);",
          "vec4 txColorBase = txColorDepthMod01;",
          "vec4 txNmBase =  txNmDepthMod01;",

          "vec4 txColor = txColorBase;",


          "vec4 lightColor = vec4(sunDir, 1.0);",
          "float intensity = max( 0.01 + dot(txNmBase.rgb, sunLightDirection ) * 0.99, 0.0);",

          "vec3 transposedFragPos = fragPos + txNmBase.xyz+ txNmBase.xyz+ txNmBase.xyz;",
          "transposedFragPos.y += sin(systemTime*1.0 + txNmDepthMod01.x*20.0)*1.51 ;",
          "transposedFragPos.x += cos(systemTime*1.0 + txNmDepthMod01.y*20.0)*1.51 ;",

          "vec3 cameraToFrag = normalize(transposedFragPos-cameraPosition);",
          "vec4 reflectionColor = texture2D( envMap, cameraToFrag.xy);",

          "vec4 baseColor = vColor * txColor * (intensity*0.25 + 0.75) + txColor * lightColor*intensity*2.0;",

          "baseColor.r = baseColor.r*depth + depth*depth*(0.3+vPosition.y);",
          "baseColor.g = baseColor.g*depth + depth*depth*(0.3+vPosition.y);",
          "baseColor.b = baseColor.b*depth + depth*depth*(0.3+vPosition.y);",

          "float normalFactor = dot(cameraToFrag, vNormal);",

          "float reflectionFactor =  0.0 + max(0.0, 1.0 - txColor.r*3.5) * cos(normalFactor*6.10*normalFactor) * 0.55;",

          "reflectionColor *=  reflectionFactor;",

          "gl_FragColor = baseColor + reflectionColor;",

          "float forElevClear = min(fogDensity*0.25, fogDensity*cameraPosition.y*0.01);",
          "float fogFactor = min((fogDensity-forElevClear) * (fogDepth*0.04), 0.12);",

          "vec3 waterFogColor = vec3(fogColor.r * 0.85 + fogColor.r*fogFactor*0.4, fogColor.g *0.85 + fogColor.g*fogFactor*0.4, fogColor.b * 0.85 + fogColor.b*fogFactor*0.5);",

          "fogFactor += min((fogDensity-forElevClear) * (fogDepth*1.5), 0.9);",
          "waterFogColor += vec3( fogColor.r*fogFactor*0.04,  fogColor.g*fogFactor*0.04,  fogColor.b*fogFactor*0.06);",

          "gl_FragColor.rgb = mix(gl_FragColor.rgb, waterFogColor,  fogFactor );",

          "}",
          ""

        ],

        "vertexBigTerrain": [

          "precision highp float;",
          "uniform sampler2D heightmap;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",

          "attribute vec4 texelRowSelect;",
          "attribute vec4 lifecycle;",
          "attribute vec4 orientation;",
          "attribute vec4 vertexColor;",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec3 offset;",
          "attribute vec3 scale3d;",
          "attribute vec2 uv;",
          "attribute vec4 sprite;",

          "uniform vec3 heightmaptiles;",

          "varying vec4 vColor;",
          "varying vec2 vUv;",
          "varying vec2 heightSampler;",

          "uniform vec3 ambientLightColor;",
          "uniform vec3 sunLightColor;",

          "uniform vec3 sunLightDirection;",
          "varying vec3 sunDir;",
          "uniform vec3 cameraPosition;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec3 faceNormal;",
          "varying vec2 tileOffset;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "varying vec2 scaledVPos;",
          "varying vec2 center;",
          "varying float elevationFactor;",
          "varying float distScaleX;",
          "varying float distScaleZ;",
          "void main(){",

          "float elementScale = texelRowSelect.w;",
          "float outerness =  texelRowSelect.z;",

          "elevationFactor = (1.0+floor(cameraPosition.y * 0.002))*outerness;",

          "float dirX = sign(position.x);",
          "float dirZ = sign(position.z);",

          "distScaleX = floor(abs(position.x-0.5*dirX)*0.0011);",
          "distScaleX += floor(abs(position.x-0.5*dirX)*0.0010);",
          "distScaleX += floor(abs(position.x-0.5*dirX)*0.00099)*1.0;",
          "distScaleX += floor(abs(position.x-0.5*dirX)*0.00098)*2.0;",
          "distScaleX += floor(abs(position.x-0.5*dirX)*0.00096)*4.0;",


          "distScaleZ = floor(abs(position.z-0.5*dirZ)*0.0011);",
          "distScaleZ += floor(abs(position.z-0.5*dirZ)*0.0010);",
          "distScaleZ += floor(abs(position.z-0.5*dirZ)*0.00099)*1.0;",
          "distScaleZ += floor(abs(position.z-0.5*dirZ)*0.00098)*2.0;",
          "distScaleZ += floor(abs(position.z-0.5*dirZ)*0.00096)*4.0;",

          "float txw = heightmaptiles.z;",
          "float txPointOffset = 1.0/(txw+1.0);",
          "float tileFactorX = 2.0/(txw);",
          "float tileFactorZ = 2.0/(txw);",

          "vPosition.x = (position.x + dirX * distScaleX)*elevationFactor;",
          "vPosition.z = (position.z + dirZ * distScaleZ)*elevationFactor;",


          "float shift = txPointOffset * 1.0;",
          "float shiftSubOne = 1.0/(txw-1.0);",
          "center.x = floor(offset.x / (elevationFactor*elementScale)) * elevationFactor*elementScale;",
          "center.y = floor(offset.z / (elevationFactor*elementScale)) * elevationFactor*elementScale;",

          "vec4 quat = orientation.xyzw;",



          "terrainPosition.x = vPosition.x*tileFactorX;",
          "terrainPosition.y = 0.0;",
          "terrainPosition.z = vPosition.z*tileFactorZ;",


          "tileOffset = vec2(0.0, 0.0);",

          "scaledVPos.x =  ((center.x*(1.0-shift)) * shiftSubOne+shift*0.0  + (terrainPosition.x ) * 0.5 + 0.5);",
          "scaledVPos.y =  ((center.y*(1.0-shift)) * shiftSubOne+shift*0.0  + (terrainPosition.z ) * 0.5 + 0.5);",

          "scaledVPos.x = floor(scaledVPos.x*2.0*(txw))*0.5*shift;",
          "scaledVPos.y = floor(scaledVPos.y*2.0*(txw))*0.5*shift;",

          "heightSampler.x = scaledVPos.x;",
          "heightSampler.y = scaledVPos.y;",

          "vec4 sample = texture2D( heightmap, heightSampler);",

          "vec2 normalSamplerP0 = vec2(heightSampler.x +shift*0.5 , heightSampler.y +shift*0.5);",
          "vec4 normalSampleP0 = texture2D( heightmap, normalSamplerP0);",

          "vec2 normalSamplerP1 = vec2(normalSamplerP0.x - shift*1.0, normalSamplerP0.y);",
          "vec4 normalSampleP1 = texture2D( heightmap, normalSamplerP1);",

          "vec2 normalSamplerP2 = vec2(normalSamplerP0.x, normalSamplerP0.y - shift*1.0);",
          "vec4 normalSampleP2 = texture2D( heightmap, normalSamplerP2);",

          "vec3 triPoint0 = vec3( normalSamplerP0.x, normalSampleP0.x/scale3d.y, normalSamplerP0.y);",
          "vec3 triPoint1 = vec3( normalSamplerP1.x, normalSampleP1.x/scale3d.y, normalSamplerP1.y);",
          "vec3 triPoint2 = vec3( normalSamplerP2.x, normalSampleP2.x/scale3d.y, normalSamplerP2.y);",

          "vec3 tangent = triPoint2 - triPoint0;",
          "vec3 biTangent = triPoint1 - triPoint0;",
          "vNormal = normalize(cross(tangent, biTangent));",

          "vUv.x = mod((vPosition.x/256.0)+0.5, 1.0);",
          "vUv.y = mod((vPosition.z/256.0)+0.5, 1.0);",

          "vPosition.y = -3.0 + sample.x * scale3d.y;",

          "vPosition.x += center.x -0.5;",
          "vPosition.z += center.y -0.5;",


          "faceNormal = vNormal + 2.0 * cross( orientation.xyz, cross( orientation.xyz, vNormal ) + orientation.w * vNormal );",

          "float intensity = max( -0.25 + dot(faceNormal, sunLightDirection ) * 1.0, 0.0);",
          "sunDir = sunLightColor * intensity;",

          "float ambIntensity = 0.75;",

          "vColor.r = sunDir.r + ambientLightColor.r * ambIntensity ;",
          "vColor.g = sunDir.g + ambientLightColor.g * ambIntensity;",
          "vColor.b = sunDir.b + ambientLightColor.b * ambIntensity;",
          "vColor.a = 1.0;",

          "gl_Position = projectionMatrix * modelViewMatrix * vec4( vPosition, 1.0 );",
          "fogDepth = gl_Position.z*1.0;",
          "}",
          ""
        ],

        "fragmentBigTerrain":[
          "precision highp float;",

          "uniform vec3 sunLightDirection;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "uniform sampler2D terrainmap;",
          "uniform sampler2D heightmap;",
          "uniform sampler2D tx0;",
          "uniform sampler2D tx0nm;",
          "uniform sampler2D tx1;",
          "uniform vec2 tx0tiles;",
          "varying vec2 vUv;",
          "varying vec3 sunDir;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec4 vColor;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec3 faceNormal;",
          "varying vec2 tileOffset;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "varying vec2 scaledVPos;",
          "varying float elevationFactor;",
          "varying float distScaleX;",
          "varying float distScaleZ;",
          "void main(){",

          "vec2 terrainSampler = scaledVPos;",
          "vec4 terrainMapSample = texture2D( terrainmap, terrainSampler);",
          "vec4 heightMapSample = texture2D( heightmap, terrainSampler);",

          "int gIndex = int(min(terrainMapSample.r*8.0, 4.0));",
          "float biomeIndex = float(gIndex);",

          "float shift = 1.0/2048.0;",




          "vec2 tileScale = 1.0/tx0tiles;",
          "float tileCount = tx0tiles.x*16.0;",

          "float tileXuv = (max(0.001, min(mod(vUv.x*elevationFactor, 1.0), 0.999)) * tileCount);",
          "float tileYuv = (max(0.001, min(mod(vUv.y*elevationFactor, 1.0), 0.999)) * tileCount);",
          "float uvX = ((tileXuv * 1.0 - floor(tileXuv * 1.0005)*0.99995)) * 1.0;",
          "float uvY = ((tileYuv * 1.0 - floor(tileYuv * 1.0005)*0.99995)) * 1.0;",
          "float pixelShrink = 0.07;",
          "vec2 tileUv = vec2(pixelShrink + uvX*(1.0-pixelShrink*2.0), pixelShrink + uvY*(1.0-pixelShrink*2.0));",
          "vec2 scaledUv = tileUv*tileScale;",

          "float sampledHeight = heightMapSample.r;",
          "float sampleBlue = terrainMapSample.b;",
          "float sampleGreen = terrainMapSample.g;",

          "float biomeOffset =  biomeIndex*3.0;",

          "float rockRow = 1.0 + biomeOffset;",
          "float slopeScale = 0.98;",
          "float natureRow = 2.0 + biomeOffset;",
          "float natureStep = 0.03;",

          "float slope = cos(vNormal.y*1.571)*3.14;",


          "slope = slope * 0.998 + 0.03*slope*sin(scaledVPos.x * 200.0)  + 0.03*slope*cos(scaledVPos.y * 200.0);",
          "slope = slope * 0.998 + 0.03*slope*sin(scaledVPos.y * 742.0)  + 0.03*slope*cos(scaledVPos.x * 742.0);",

          "float scatter = (cos(scaledUv.x*313.0) + sin(scaledUv.y*313.0))*0.0015;",

          "vec2 tile01 = vec2(min(floor((sampleGreen+scatter) * 10.0), 7.0), natureRow);",
          "vec2 tile01Offset = vec2(tile01.x * tileScale.x, (tile01.y-1.0) * tileScale.y);",

          "vec2 tile01Uv = vec2(scaledUv + tile01Offset);",
          "vec4 natureColor = texture2D(tx0, tile01Uv);",
          "vec4 natureNormal = texture2D(tx0nm, tile01Uv);",

          "float natureMix = min(max(-natureStep*0.25 + sampleGreen, 0.0)/natureStep*1.0, 1.0);",

          "vec2 tileSlopeMod = vec2(min(floor(max(sqrt(slope -0.01) +scatter*4.0, 0.01) * 10.0), 7.0), rockRow);",
          "vec2 tileSlopeModOffset = vec2(tileSlopeMod.x * tileScale.x, (tileSlopeMod.y-1.0) * tileScale.y);",

          "vec2 tileSlopeModUv = vec2(scaledUv + tileSlopeModOffset);",
          "vec4 txColorSlopeMod01 = texture2D( tx0, tileSlopeModUv);",
          "vec4 txNmSlopeMod01 = texture2D( tx0nm, tileSlopeModUv);",
          "vec4 txColor = txColorSlopeMod01;",
          "vec4 txNmBase =  txNmSlopeMod01;",

          "txColor = mix( txColor, natureColor,  natureMix);",
          "txNmBase = mix( txNmBase, natureNormal,  natureMix);",

          "float civRow = 3.0 + biomeOffset;",
          "float civStep = 0.04;",

          "tile01 = vec2(min(floor((sampleBlue+scatter*8.0) * 10.0), 7.0), civRow);",
          "tile01Offset = vec2(tile01.x * tileScale.x, (tile01.y-1.0) * tileScale.y);",
          "tile01Uv = vec2(scaledUv + tile01Offset);",
          "vec4 civColor = texture2D(tx0, tile01Uv);",
          "vec4 civNormal = texture2D(tx0nm, tile01Uv);",

          "float civMix = min(max(-civStep*1.2 + sampleBlue, 0.0)/civStep*1.0, 1.0);",
          "txColor = mix(txColor, civColor,  civMix);",
          "txNmBase = mix(txNmBase, civNormal,  civMix);",

          "float waterline = min(1.0 - min(((vPosition.y+scatter*52.0)*2.0-slope*2.0*scatter*121.0) * 2.0, 1.0), 1.0);",
          "txColor = txColor - txColor*waterline*0.65 ;",

          "float shadowing = 1.0 - heightMapSample.b*0.55;",
          "vec4 lightColor = vec4(sunDir, 1.0) * shadowing;",
          "float intensity = max( 0.01 + dot(txNmBase.rgb, sunLightDirection ) * 0.99, 0.0) * shadowing;",
          "gl_FragColor = (shadowing * vColor * txColor * (intensity*0.25 + 0.75) + txColor * lightColor*intensity*2.0) * shadowing;",
          "float fogFactor = min(fogDensity * fogDepth, 1.0);",
          "gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor,  fogFactor );",

          "}",
          ""

        ],


        "_skip": [
          "vec2 normalSamplerP0 = vec2(terrainSampler.x +shift*0.5 , terrainSampler.y +shift*0.5);",
          "vec4 normalSampleP0 = texture2D( heightmap, normalSamplerP0);",

          "vec2 normalSamplerP1 = vec2(normalSamplerP0.x - shift*1.0, normalSamplerP0.y);",
          "vec4 normalSampleP1 = texture2D( heightmap, normalSamplerP1);",

          "vec2 normalSamplerP2 = vec2(normalSamplerP0.x, normalSamplerP0.y - shift*1.0);",
          "vec4 normalSampleP2 = texture2D( heightmap, normalSamplerP2);",

          "vec3 triPoint0 = vec3( normalSamplerP0.x, normalSampleP0.x*0.01, normalSamplerP0.y);",
          "vec3 triPoint1 = vec3( normalSamplerP1.x, normalSampleP1.x*0.01, normalSamplerP1.y);",
          "vec3 triPoint2 = vec3( normalSamplerP2.x, normalSampleP2.x*0.01, normalSamplerP2.y);",

          "vec3 tangent = triPoint2 - triPoint0;",
          "vec3 biTangent = triPoint1 - triPoint0;",
          "vec3 fragNormal = normalize(cross(tangent, biTangent));"
        ],

        "vertexTerrainInstancing": [

          "precision highp float;",
          "uniform sampler2D heightmap;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",

          "attribute vec4 texelRowSelect;",
          "attribute vec4 lifecycle;",
          "attribute vec4 orientation;",
          "attribute vec4 vertexColor;",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec3 offset;",
          "attribute vec3 scale3d;",
          "attribute vec2 uv;",
          "attribute vec4 sprite;",

          "uniform vec3 heightmaptiles;",

          "varying vec4 vColor;",
          "varying vec2 vUv;",
          "varying vec2 heightSampler;",

          "uniform vec3 ambientLightColor;",
          "uniform vec3 sunLightColor;",

          "uniform vec3 sunLightDirection;",
          "varying vec3 sunDir;",

          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec3 faceNormal;",
          "varying vec2 tileOffset;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "void main(){",

          "vPosition = position;",
          "terrainPosition = position;",
          "float txw = heightmaptiles.z;",
          "float txPointOffset = 1.0/txw;",
          "float shift = txPointOffset * 1.0;",
          "vec4 quat = orientation.xyzw;",

          "vUv = uv;",

          "tileScale = 1.0/heightmaptiles.xy;",

          "tileOffset = vec2(sprite.x * tileScale.x + txPointOffset*0.5, sprite.y * tileScale.y + txPointOffset*0.5);",

          "vec2 scaledVPos = vec2(position.x*0.5 + 0.5, position.z *0.5 + 0.5)*tileScale;",

          "heightSampler = (scaledVPos + tileOffset);",

          "vec4 sample = texture2D( heightmap, heightSampler);",

          "vec2 normalSamplerP0 = vec2(heightSampler.x +shift*0.5 , heightSampler.y +shift*0.5);",
          "vec4 normalSampleP0 = texture2D( heightmap, normalSamplerP0);",

          "vec2 normalSamplerP1 = vec2(normalSamplerP0.x - shift, normalSamplerP0.y);",
          "vec4 normalSampleP1 = texture2D( heightmap, normalSamplerP1);",

          "vec2 normalSamplerP2 = vec2(normalSamplerP0.x, normalSamplerP0.y - shift);",
          "vec4 normalSampleP2 = texture2D( heightmap, normalSamplerP2);",

          "vec3 triPoint0 = vec3( normalSamplerP0.x, normalSampleP0.x*0.01, normalSamplerP0.y);",
          "vec3 triPoint1 = vec3( normalSamplerP1.x, normalSampleP1.x*0.01, normalSamplerP1.y);",
          "vec3 triPoint2 = vec3( normalSamplerP2.x, normalSampleP2.x*0.01, normalSamplerP2.y);",

          "vec3 tangent = triPoint2 - triPoint0;",
          "vec3 biTangent = triPoint1 - triPoint0;",

          "vPosition.x = vPosition.x *  scale3d.x;",
          "vPosition.y = sample.x*100.0*scale3d.y + vPosition.y *  scale3d.y * 20.0;",
          "vPosition.z = vPosition.z *  scale3d.z;"  ,



          "vNormal = normalize(cross(tangent, biTangent));",
          "faceNormal = vNormal + 2.0 * cross( orientation.xyz, cross( orientation.xyz, vNormal ) + orientation.w * vNormal );",

          "float intensity = max( -0.25 + dot(faceNormal, sunLightDirection ) * 1.0, 0.0);",
          "sunDir = sunLightColor * intensity;",

          "float ambIntensity = 0.75;",

          "vColor.r = sunDir.r + ambientLightColor.r * ambIntensity ;",
          "vColor.g = sunDir.g + ambientLightColor.g * ambIntensity;",
          "vColor.b = sunDir.b + ambientLightColor.b * ambIntensity;",
          "vColor.a = 1.0;",

          "gl_Position = projectionMatrix * modelViewMatrix * vec4( offset + vPosition, 1.0 );",
          "fogDepth = gl_Position.z*1.0;",
          "}",
          ""
        ],

        "fragmentTerrainInstancing":[
          "precision highp float;",

          "uniform vec3 sunLightDirection;",
          "uniform vec3 fogColor;",
          "uniform float fogDensity;",
          "uniform sampler2D terrainmap;",
          "uniform sampler2D heightmap;",
          "uniform sampler2D tx0;",
          "uniform sampler2D tx0nm;",
          "uniform sampler2D tx1;",
          "uniform vec2 tx0tiles;",
          "varying vec2 vUv;",
          "varying vec3 sunDir;",
          "varying float fogDepth;",
          "varying float vFragDepth;",
          "varying vec4 vColor;",
          "varying vec3 vPosition;",
          "varying vec3 vNormal;",
          "varying vec3 faceNormal;",
          "varying vec2 tileOffset;",
          "varying vec2 tileScale;",
          "varying vec3 terrainPosition;",
          "void main(){",




          "vec2 scaledVPos = vec2(terrainPosition.x*0.5 + 0.5, terrainPosition.z *0.5 + 0.5)*tileScale;",
          "vec2 terrainSampler = (scaledVPos + tileOffset);",
          "vec4 terrainMapSample = texture2D( terrainmap, terrainSampler);",
          "vec4 heightMapSample = texture2D( heightmap, terrainSampler);",

          "int gIndex = int(min(terrainMapSample.r*8.0, 4.0));",
          "float biomeIndex = float(gIndex);",

          "float twoPi = 6.2831;",
          "float slope = cos(vNormal.y*1.571)*1.35;",

          "slope = slope * 0.998 + 0.10*slope*sin(vPosition.x * twoPi*0.25)  + 0.22*slope*cos(vPosition.z * twoPi*1.0);",
          "slope = slope * 0.998 + 0.14*slope*sin(vPosition.x * twoPi*0.25)  + 0.08*slope*cos(vPosition.z * twoPi*0.125);",
          "slope = slope * 0.998 + 0.08*slope*sin(vPosition.x * twoPi*1.0)   + 0.14*slope*cos(vPosition.z * twoPi*0.5);",

          "vec4 sprite = vec4(0.0, 8.0, 1.0, 1.0);",
          "vec2 tileScale = 1.0/tx0tiles;",
          "tileScale.y /= sprite.z;",


          "float tileCount = tx0tiles.x;",
          "float tileXuv = max(0.001, min(vUv.x*1.0, 0.999)) * tileCount;",
          "float tileYuv = max(0.001, min(vUv.y*1.0, 0.999)) * tileCount;",
          "float uvX = (tileXuv * 1.0 - floor(tileXuv * 1.0005)*0.99995) * 1.0;",
          "float uvY = (tileYuv * 1.0 - floor(tileYuv * 1.0005)*0.99995) * 1.0;",
          "vec2 tileUv = vec2(0.007 + uvX*0.988, 0.007 + uvY*0.988);",
          "vec2 scaledUv = tileUv*tileScale * 1.0;",
          "scaledUv.y /= sprite.z;",

          "float smoothFactor  = 0.0;",
          "float sampleBlue = terrainMapSample.b;",
          "float sampleGreen = terrainMapSample.g;",

          "float biomeOffset =  biomeIndex*3.0;",

          "float rockRow = 1.0 + biomeOffset;",
          "float slopeScale = 0.98;",
          "float natureRow = 2.0 + biomeOffset;",
          "float natureStep = 0.06;",

          "float scatter = (cos(vPosition.z*113.0) + sin(vPosition.x*113.0))*0.002 + (cos(vPosition.z*25.0) + sin(vPosition.x*25.0))*0.002;",

          "vec2 tile01 = vec2(min(floor((sampleGreen+scatter) * 10.0), 7.0), natureRow);",
          "vec2 tile01Offset = vec2(tile01.x * tileScale.x, (tile01.y-sprite.w) * tileScale.y / sprite.z);",



          "vec2 tile01Uv = vec2(scaledUv + tile01Offset);",
          "smoothFactor = smoothstep(-0.01, natureStep*0.5, sampleGreen) - smoothstep(natureStep*2.0, natureStep*3.0, sampleGreen);",
          "vec4 natureColor = texture2D(tx0, tile01Uv);",
          "vec4 natureNormal = texture2D(tx0nm, tile01Uv);",

          "float natureMix = min(max(-natureStep*0.25 + sampleGreen, 0.0)/natureStep*1.0, 1.0);",

          "vec2 tileSlopeMod = vec2(min(floor(max(sqrt(slope -0.01) +scatter*4.0, 0.01) * 10.0), 7.0), rockRow);",
          "vec2 tileSlopeModOffset = vec2(tileSlopeMod.x * tileScale.x, (tileSlopeMod.y-sprite.w) * tileScale.y / sprite.z);",



          "tileSlopeMod *= 1.0;",
          "tileSlopeModOffset *= 1.0;",

          "vec2 tileSlopeModUv = vec2(scaledUv + tileSlopeModOffset);",
          "tileSlopeModUv *= 1.0;",
          "vec4 txColorSlopeMod01 = texture2D( tx0, tileSlopeModUv);",
          "vec4 txNmSlopeMod01 = texture2D( tx0nm, tileSlopeModUv);",
          "vec4 txColorBase = txColorSlopeMod01;",
          "vec4 txNmBase =  txNmSlopeMod01;",

          "txColorBase = mix( txColorBase, natureColor,  natureMix);",
          "txNmBase = mix( txNmBase, natureNormal,  natureMix);",

          "float civRow = 3.0 + biomeOffset;",
          "float civStep = 0.07;",

          "tile01 = vec2(min(floor((sampleBlue+scatter*8.0) * 10.0), 7.0), civRow);",
          "tile01Offset = vec2(tile01.x * tileScale.x, (tile01.y-sprite.w) * tileScale.y / sprite.z);",
          "tile01Uv = vec2(scaledUv + tile01Offset);",
          "smoothFactor = smoothstep(-0.01, civStep*0.9, sampleBlue) - smoothstep(civStep*1.5, civStep*2.2, sampleBlue);",
          "vec4 civColor = texture2D(tx0, tile01Uv);",
          "vec4 civNormal = texture2D(tx0nm, tile01Uv);",

          "float civMix = min(max(-civStep*1.2 + sampleBlue, 0.0)/civStep*1.0, 1.0);",
          "txColorBase = mix(txColorBase, civColor,  civMix);",
          "txNmBase = mix(txNmBase, civNormal,  civMix);",

          "vec4 txColor = txColorBase;",

          "txColor.r += vNormal.x * 0.0 + tileUv.x *0.0;",
          "txColor.g += vNormal.y * 0.0 + tileUv.y *0.0;",
          "txColor.b += vNormal.z * 0.0;",
          "float shadowing = 1.0 - heightMapSample.b*0.55;",
        "vec4 lightColor = vec4(sunDir, 1.0) * shadowing;",
        "float intensity = max( 0.01 + dot(txNmBase.rgb, sunLightDirection ) * 0.99, 0.0) * shadowing;",
        "gl_FragColor = (shadowing * vColor * txColor * (intensity*0.25 + 0.75) + txColor * lightColor*intensity*2.0) * shadowing;",
        "float fogFactor = min(fogDensity * fogDepth, 1.0);",
          "gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor,  fogFactor );",

          "}",
          ""

        ]
      }
    }
  }
]
